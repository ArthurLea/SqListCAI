using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SqListCAI.Utils.SourceCodes
{
    public partial class Explain
    {
        public static string OrderInsExplain = 
            "在线性表的顺序存储结构中，由于逻辑上相邻的数据元素在物理位置上\n" +
            "也相邻，因此，除非插入位置i的值等于表长加1（即插入在表尾之后），\n"+
            "否则都必须移动元素才能反映这个逻辑关系的变化。一般情况下，在第\n"+
            "i（1<i<(n+1)）个元素之前插入一个元素时，需将第n个至第i个，共"+
            "n-i+1个元素依次向后移动一个位置。";
        public static string OrderDelExplain =
            "和顺序表插入相反，从顺序表中删除第i（1<i<n）个\n"+
            "元素时，需将从第i+1至第n个，共n-1个元素依次向后移动一个位置";

        public static string LinkedCreExplain =
            "这是一个从表尾到表头逆行建立线性表的算法（头插法）。每生成\n" +
            "一个新的结点，都插入在第一个结点之前，也即表头结点之后，因此，\n" +
            "只需要修改表头结点中的指针域的值，但在这之前，必须先将其值赋给\n" +
            "新结点的指针域";
        public static string LinkedInsExplain = 
            "算法中的参数i表示插入的位置，其合理值的范围为1至表长+1,。插入\n"+
            "时，首先需要查找插入位置，由于表头也是链表元素，因此在第i个元素\n"+
            "之前插入，注意：在查找的过程中，始终保持活动指针指向链表中的第j\n"+
            "个结点，则j=0时，p应该指向头结点。本算法约定新结点插入在第i个结\n"+
            "点之前，则需要修改第i-1个结点中的指针域的值。注意查找时循环结束的条件";
        public static string LinkedDelExplain =
            "算法中的参数i表示删除额位置，其合理值的范围为1至表长。首先需要\n" +
            "查找被删除结点所在的位置，由于表头也是链表元素，因此删除第i个\n"+
            "元素也就是删除头结点后的第i-1个，需要找到它的前驱，也就是头结点\n"+
            "之后的第i-2个位置,同时在找到第i-2个位置时，需要判断其后是否为空，\n"+
            "为空或者没有找到都表示删除位置错。在查找的过程中，活动指针始终保持指向\n" +
            "头结点，则j=0时，p应该指向头结点。从链表中删除第i个结点，则需\n" +
            "要修改第i-1个结点的指针域的值。注意，查找删除位置时的循环条件\n" +
            "同插入算法的不同处。";
        public static string OrderSearchExplain =
            "顺序查找的查找过程是：首先在顺序表的下端增设其关键值给定值相同的\n" +
            "'监视器'，然后从表中最后一个记录开始，逐个进行记录的关键字和给定\n" +
            "值的比较，直到两者相等，若表中存在其关键字和给定值相等的记录，则\n" +
            "查找结束的位置恰为该记录在表中的位置，否则'比较'直至监视器哨停止，\n" +
            "查找不成功。";
        public static string BinarySearchExplain =
            "折半查找的过程是：线确定待查记录所在的范围（区间），然后逐步缩小\n" +
            "查找范围，直至找到该记录或者找不到为止。所谓'折半'的含义是指，先将\n" +
            "给定值和所查区间中间位置的记录的关键字进行比较，若相等，则查找成功；\n" +
            "否则，判断判断与此关键字的大小，若比关键字小，就继续在关键字前半个区\n" +
            "间中查找，否则在后半个区间进行查找，依次循环这个算法。";
        public static string InsertSortExplain =
            "一趟直接插入排序的基本操作是：将一个记录插入到一个有序的子序列中，\n" +
            "从而使有序子序列的长度增1。一般情况下，第i趟直接插入排序的操作为：\n" +
            "在含有i-1个记录的有序子序列r[1...i-1]中插入一个记录r[i]，变成含有i" +
            "个记录的有序子序列r[1..i]，整个排序过程中需要进行n-1趟的插入，即：\n" +
            "i从2到n,时间复杂度为O(n^2)，稳定。00";
        public static string SwapSortExplain =
            "比较相邻两个记录的关键字，若r[i]>r[i+1]则交换之，其中i从1到n-pass\n" +
            "（初值为1）称之为一趟冒泡排序，其中结果是使用最大关键字的记录被交\n" +
            "换到n-pass+1的位置上，最坏的情况下需要进行n-1趟排序。\n" +
            "如果某一趟中没有进行过一次记录的交换，则排序提前结束，因此，冒泡\n" +
            "排序的最好记录是进行一趟“冒泡”。O最好为O(1),最坏为O(n^2)，稳定。";
        public static string PartitionSortExplain =
            "快速排序的基本思想为：首先选取一个记录作为枢纽（也称为支点）\n" +
            "（不失一般性，可选择第一个记录），以它的关键字为基准重排其余\n" +
            "记录，将所有的关键字比它大的记录都安置在它之后，而将所有关键字\n" +
            "比它小的记录都安置在它的之前，由此完成一趟快速排序，之后，分别对由\n" +
            "一趟排序分割成的两个子序列进行快速排序"; 
    }
}
